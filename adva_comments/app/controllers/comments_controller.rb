class CommentsController < BaseController
  # TODO apparently it is not possible to use protect_from_forgery with
  # page cached forms? is that correct? as protect_from_forgery seems to
  # validate the form token against the session and ideally when all pages
  # and assets are cached there is no session at all this seems to make sense.
  #
  # Rails docs say: "done by embedding a token based on the session ... in all
  # forms and Ajax requests generated by Rails and then verifying the authenticity
  # of that token in the controller"
  # http://api.rubyonrails.org/classes/ActionController/RequestForgeryProtection/ClassMethods.html
  #
  # Note: Could fetch forgery token via AJAX?

  protect_from_forgery :except => [:preview, :create]

  authenticates_anonymous_user
  layout 'default'

  before_filter :set_section
  before_filter :set_comment, :only => [:show, :update, :destroy]
  before_filter :set_commentable, :only => [:show, :preview, :create]
  before_filter :set_comment_params, :only => [:preview, :create]

  guards_permissions :comment, :except => :show, :create => :preview

  def show
  end

  def preview
    @comment = @commentable.comments.build(params[:comment])
    @comment.send(:process_filters)
    render :layout => false
  end

  def create
    @comment = @commentable.comments.build(params[:comment])
    if @comment.save
      trigger_events @comment
      if current_user.anonymous
        flash[:notice] = "Your comment is being reviewed, and will be posted shortly. Thank you for commenting!"
      else
        @comment.update_attribute :approved, true
        flash[:notice] = "You're an admin, so your comment is being posted immediately! Refresh the page to see it."
      end
      respond_to do |format|
        format.html { redirect_to "#{url_for([@commentable.section, @commentable])}#comments" }
        format.js { render :json => true }
      end
    else
      flash[:error] = @comment.errors.full_messages.to_sentence # TODO hu.
      respond_to do |format|
        format.html { redirect_to "#{url_for([@commentable.section, @commentable])}#comments" }
        format.js { render :json => false }
      end
    end
  end

  def update
    if @comment.update_attributes(params[:comment])
      trigger_events(@comment)
      flash[:notice] = t(:'adva.comments.flash.update.success')
      render :json => true
    else
      set_commentable
      flash[:error] = @comment.errors.full_messages.to_sentence
      render :json => false
    end
  end

  def destroy
    @comment.destroy
    trigger_events @comment
    flash[:notice] = t(:'adva.comments.flash.destroy.success')
    redirect_to "/"
  end

  protected

    def set_comment
      @comment = Comment.find params[:id]
    end

    def set_commentable
      @commentable = if @comment
        @comment.commentable
      else
        params[:comment][:commentable_type].constantize.find(params[:comment][:commentable_id])
      end
      raise ActiveRecord::RecordNotFound unless @commentable
    end

    def set_comment_params
      return unless params[:comment]

      params[:comment].delete(:approved)  # TODO use attr_protected api?
      params[:comment].merge!(:site_id => @commentable.site_id,
                              :section_id => @commentable.section_id,
                              :author => current_user)
    end

    def current_resource
      @comment || @commentable
    end
end
